package sio.groupK;

import java.lang.management.ManagementFactory;
import java.lang.management.ThreadMXBean;
import java.util.Arrays;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicLong;
import java.util.stream.Stream;
import sio.tsp.RandomTour;
import sio.tsp.TspConstructiveHeuristic;
import sio.tsp.TspData;
import sio.tsp.TspImprovementHeuristic;
import sio.tsp.TspTour;

public final class Main {

    private static final int RANDOM_SEED = 0x134B3BD;

    /**
     * List of datasets and their optimal length.
     */
    private static final DatasetPair[] datasets = {
            new DatasetPair("data/att532.dat", 86729),
            new DatasetPair("data/rat575.dat", 6773),
            new DatasetPair("data/rl1889.dat", 316536),
            new DatasetPair("data/u574.dat", 36905),
            new DatasetPair("data/u1817.dat", 57201),
            new DatasetPair("data/vm1748.dat", 336556),
    };

    /**
     * List of constructive heuristics to test from.
     */
    private static final TspConstructiveHeuristic[] constructiveHeuristics = {
            new NearestNeighbor(),
            new DoubleEndsNearestNeighbor(),
    };

    /**
     * List of augmenting heuristics to test from.
     */
    private static final TspImprovementHeuristic[] improvementHeuristics = {
            new TwoOptFirstImprovement(),
            new TwoOptBestImprovement(),
    };

    public static void main(String[] args) throws Exception {
        // We will use a thread pool to parallelize our computations.
        ExecutorService threadPool = Executors.newFixedThreadPool(5);

        // We want to compute stats for every dataset and every heuristic.
        for (var dataset : datasets) {
            System.out.printf(
                    "%n%nDataset: %s (optimal length %d)%n",
                    dataset.filename,
                    dataset.optimalLength
            );
            // Load the data for the current dataset
            TspData data = TspData.fromFile(dataset.filename);

            var randomGen = new RandomTour(RANDOM_SEED);
            TspTour randomTour = randomGen.computeTour(data, 0);

            int[] startingCities = Arrays.copyOfRange(randomTour.tour(), 0, 10);

            for (var impHeuristic : improvementHeuristics) {
                System.out.println("#".repeat(80));
                System.out.printf("Improvement heuristic: %s%n", impHeuristic.getClass().getSimpleName());
                Stream.concat(
                        Arrays.stream(constructiveHeuristics),
                        Stream.of(new RandomTour(RANDOM_SEED))
                ).forEach(tourHeuristic -> {
                    AtomicLong min = new AtomicLong(Long.MAX_VALUE);
                    AtomicLong max = new AtomicLong();
                    AtomicLong avg = new AtomicLong();
                    AtomicLong avgTime = new AtomicLong();

                    Arrays.stream(startingCities).mapToObj(city -> CompletableFuture.runAsync(() -> {
                        TspTour initial = tourHeuristic.computeTour(data, city);

                        // We will use the used CPU time to measure the time taken by the
                        // heuristic, to have a more accurate measure of the time taken.
                        ThreadMXBean threadMx = ManagementFactory.getThreadMXBean();
                        long start = threadMx.getCurrentThreadCpuTime();
                        TspTour tour = impHeuristic.computeTour(initial);
                        long end = threadMx.getCurrentThreadCpuTime();

                        // Update our running average and min/max values if needed.
                        long length = tour.length();
                        min.getAndUpdate(v -> Math.min(v, length));
                        max.getAndUpdate(v -> Math.max(v, length));
                        avg.addAndGet(length);
                        avgTime.addAndGet(end - start);
                    }, threadPool)).reduce(CompletableFuture::allOf).orElseThrow().join();

                    // compute the average time of computation and average tour length
                    avg.updateAndGet(v -> v / startingCities.length);
                    avgTime.updateAndGet(v -> v / startingCities.length);

                    // Log our results
                    System.out.println("-".repeat(80));
                    System.out.printf(
                            "Tour generated by %s (average tour compute time %.2f ms)%n",
                            tourHeuristic.getClass().getSimpleName(),
                            avgTime.get() / 1_000_000.0
                    );
                    System.out.printf("Min: %d (%.2f%% of optimal)%n", min.get(), 100.0 * min.get() / dataset.optimalLength);
                    System.out.printf("Avg: %d (%.2f%% of optimal)%n", avg.get(), 100.0 * avg.get() / dataset.optimalLength);
                    System.out.printf("Max: %d (%.2f%% of optimal)%n", max.get(), 100.0 * max.get() / dataset.optimalLength);
                });
            }
        }

        threadPool.shutdown();
    }

    /**
     * Represents a dataset and its optimal length.
     *
     * @param filename      Filename of the dataset
     * @param optimalLength Optimal length of the dataset
     */
    private record DatasetPair(
            String filename,
            long optimalLength
    ) {
    }
}
